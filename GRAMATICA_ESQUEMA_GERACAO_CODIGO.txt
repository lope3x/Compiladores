TP01, T02, T03 e T04 - Compiladores - 2021/2
G07 - Bruno Duarte de Paula Assis (639985), Gabriel Lopes Ferreira(619148), Giovanni Carlos Guaceroni(636206)

Gramática da linguagem utilizando expressões regulares com o esquema de geração de código. Como a geração de código
só ocorre após a validação do semântico não há nenhuma validação de tipos no esquema abaixo.

Start -> {Declaração; | Comando} EOF
Bloco_ou_Comando -> Comando | Bloco
Bloco -> "{"{Comando}"}"
Tipo -> int  | float  | string  | char
Declaração -> Tipo  Declaração_Init {, Declaração_Init} | const id = [-] const_value (5)
Declaração_Init ->  id  [<- [-] const_value (5)] (6)
Escrita -> "("Expressão(3) {, Expressão(3)} ")"(4)
Comando -> id  ["["Expressão_1"]"] <- Expressão_2 (20) ; | Repetição | Teste | ; readln"("id  ")" ; |(write (1) | writeln (2)) Escrita ;
Repetição -> while (21) Expressão (22) Bloco_ou_Comando (23)
Teste -> if Expressão (24)  Bloco_ou_Comando (25)[else Bloco_ou_Comando] (26)
Operadores_Relacional -> =  | !=  | < | >  | <=  | >=
Expressão -> Expressão1_1 (18) [Operadores_Relacional Expressão1_2(19) ]
Expressão1 -> [-] Expressão2_1(16)  {(-  | +  | ||  )  Expressão2_2 (17)}
Expressão2 -> Expressão3_1(14) {(* | && | / | div | mod) Expressão3_2 (15) }
Expressão3 -> {!} Expressão4 (13)
Expressão4 -> ( (int  | float ) "("Expressão ")" (12) | Expressão5 (11) )
Expressão5 -> "(" Expressão  ")"(10) | Expressão6 (9)
Expressão6 -> const_value (7) | id  ["[" Expressão  "]"] (8)



(1) {
    escrita.isWriteLn = false
}

(2) {
    escrita.isWriteLn = true
}

(3) {
    //print
    se expressão.type == String:
        mov rsi, M+expressão.end ;
        mov rdx, expressão.size ;buffer end
        mov rax, 1 ;chamada para saída
        mov rdi, 1 ;saída para tela
        syscall; chamada do sistema
    senão se expressão.type == Inteiro:
        novoTemp = getNewTemporaryAddress() //java
        mov eax, [qword + expressão.end]
        mov rsi, M+novoTemp; primeiro temp
        mov rcx, 0 ;contador pilha
        mov rdi, 0 ;tam. string convertido
        cmp eax, 0 ;verifica sinal
        jge Rot0 ;salta se número positivo
        mov bl, '-' ;senão, escreve sinal –
        mov [rsi], bl
        add rsi, 1 ;incrementa índice
        add rdi, 1 ;incrementa tamanho
        neg eax ;toma módulo do número
        Rot0:
        mov ebx, 10 ;divisor
        Rot1:
        add rcx, 1 ;incrementa contador
        cdq ;estende edx:eax p/ div.
        idiv ebx ;divide edx;eax por ebx
        push dx ;empilha valor do resto
        cmp eax, 0 ;verifica se quoc. é 0
        jne Rot1 ;se não é 0, continua
        add rdi,rcx ;atualiza tam. string
        ;agora, desemp. os valores e escreve o string
        Rot2:
        pop dx ;desempilha valor
        add dl, '0' ;transforma em caractere
        mov [rsi], dl ;escreve caractere
        add rsi, 1 ;incrementa base
        sub rcx, 1 ;decrementa contador
        cmp rcx, 0 ;verifica pilha vazia
        jne Rot2 ;se não pilha vazia, loop

        ; Interrupção de saida
        mov rsi, M+getNewTemporaryAddress ;ou buffer.end
        mov rdx, rdi ;ou buffer.tam
        mov rax, 1 ;chamada para saída
        mov rdi, 1 ;saída para tela
        syscall
    senão se expressão.type == float:
        novoTemp = getNewTemporaryAddress() //java
        movss xmm0, [qword M+expressão.end] ;real a ser impresso
        mov rsi, M+novoTemp;end. temporário
        mov rcx, 0 ;contador pilha
        mov rdi, 6 ;precisao 6 casas compart
        mov rbx, 10 ;divisor
        cvtsi2ss xmm2, rbx ;divisor real
        subss xmm1, xmm1 ;zera registrador
        comiss xmm0, xmm1 ;verifica sinal
        jae Rot0 ;salta se número positivo
        mov dl, '-' ;senão, escreve sinal –
        mov [rsi], dl
        mov rdx, -1 ;Carrega -1 em RDX
        cvtsi2ss xmm1, rdx ;Converte para real
        mulss xmm0, xmm1 ;Toma módulo
        add rsi, 1 ;incrementa índice
        Rot0:
        roundss xmm1, xmm0, 0b0011 ;parte inteira xmm1
        subss xmm0, xmm1 ;parte frac xmm0
        cvtss2si rax, xmm1 ;convertido para int
        ;converte parte inteira que está em rax
        Rot1:
        add rcx, 1 ;incrementa contador
        cdq ;estende edx:eax p/ div.
        idiv ebx ;divide edx;eax por ebx
        push dx ;empilha valor do resto
        cmp eax, 0 ;verifica se quoc. é 0
        jne Rot1 ;se não é 0, continua
        sub rdi, rcx ;decrementa precisao
        ;agora, desemp valores e escreve parte int
        Rot2:
        pop dx ;desempilha valor
        add dl, '0' ;transforma em caractere
        mov [rsi], dl ;escreve caractere
        add rsi, 1 ;incrementa base
        sub rcx, 1 ;decrementa contador
        cmp rcx, 0 ;verifica pilha vazia
        jne Rot2 ;se não pilha vazia, loop
        mov dl, '.' ;escreve ponto decimal
        mov [rsi], dl
        add rsi, 1 ;incrementa base
        ;converte parte fracionaria que está em xmm0
        Rot3:
        cmp rdi, 0 ;verifica precisao
        jle Rot4 ;terminou precisao ?
        mulss xmm0,xmm2 ;desloca para esquerda
        roundss xmm1,xmm0,0b0011 ;parte inteira xmm1
        subss xmm0,xmm1 ;atualiza xmm0
        cvtss2si rdx, xmm1 ;convertido para int
        add dl, '0' ;transforma em caractere
        mov [rsi], dl ;escreve caractere
        add rsi, 1 ;incrementa base
        sub rdi, 1 ;decrementa precisao
        jmp Rot3
        ; impressão
        Rot4:
        mov dl, 0 ;fim string, opcional
        mov [rsi], dl ;escreve caractere
        mov rdx, rsi ;calc tam str convertido
        mov rbx, M+novoTemp
        sub rdx, rbx ;tam=rsi-M-buffer.end
        mov rsi, M+novoTemp; endereço do buffer

        ; Interrupção de saida
        mov rax, 1 ;chamada para saída
        mov rdi, 1 ;saída para tela
        syscall

    senão se expressão.type == Character:
        mov rsi, M+expressão.end ;
        mov rdx, 1 ;buffer end
        mov rax, 1 ;chamada para saída
        mov rdi, 1 ;saída para tela
        syscall; chamada do sistema

}
(4) {
    //imprimir quebra de linha
    se escrita.isWriteLn:
        section .data
        db 10
        section .text
        mov rsi, M+dataCount ; pega posição do \n
        mov rdx, 1 ;1 byte apenas
        mov rax, 1 ;chamada para saída
        mov rdi, 1 ;saída para tela
        syscall; chamada do sistema
        dataCount+=1; //java
}

(5) {
    se const_value.type == String:
        id.address = dataCount//java
        id.size = 255
        section .data:
        db const_value.lex, 0
        resb 255 - const_value.size
        section .text:
        dataCount+=256//java
    senão se const_value.type == Inteiro:
        id.address = dataCount; //java
        id.size = constValue.size; //java
        section .data:
        dd const_value.lex
        section .text:
        dataCount += 4 //java
    senão se const_value.type == float:
        id.address = dataCount; //java
        id.size = constValue.size; //java
        section .data:
        se Declaração_Init.isNegative://java
        dd -const_value.lex
        senão://java
        dd const_value.lex
        section .text:
        dataCount+=const_value.size//java
    senão se const_value.type == Character:
        id.address = dataCount; //java
        id.size = 1; //java
        section .data:
        db 'const_value.lex'
        section .text:
        dataCount+= 1//java
}

(6) {
    se id.type == String:
         id.address = dataCount//java
         id.size = 255
         section .data
         resb 256
         section .text
         dataCount+=256//java
     senão se id.type == Inteiro:
         id.address = dataCount; //java
         id.size = constValue.size; //java
         section .data
         resd 1
         section .text
         dataCount += 4 //java
     senão se id.type == float:
         id.address = dataCount; //java
         id.size = constValue.size; //java
         section .data
         resd 1
         section .text
         dataCount+=4//java
     senão se id.type == Character:
         id.address = dataCount; //java
         id.size = 1; //java
         section .data
         resb 1
         section .text
         dataCount+= 1//java
}


(7) {
    se const_value.type == String:
        expressão6.address = dataCount//java
        expressão6.size = 255
        section .data:
        db const_value.lex, 0
        resb 255 - const_value.size
        section .text:
        dataCount+=256//java
    senão se const_value.type == Inteiro:
        expressão6.address = dataCount; //java
        expressão6.size = constValue.size; //java
        section .data:
        dd const_value.lex
        section .text:
        dataCount += 4 //java
    senão se const_value.type == float:
        expressão6.address = dataCount; //java
        expressão6.size = constValue.size; //java
        section .data:
        se Declaração_Init.isNegative://java
        dd -const_value.lex
        senão://java
        dd const_value.lex
        section .text:
        dataCount+=const_value.size//java
    senão se const_value.type == Character:
        expressão6.address = dataCount; //java
        expressão6.size = 1; //java
        section .data:
        db 'const_value.lex'
        section .text:
        dataCount+= 1//java
}

(8) {
    se expression6.hasStringAccess:
        mov rax, M+id.end ;endereço base da string
        mov rbx, [M+expressão.end] ;pega resultado da expressão e joga em rbx
        add rax, rbx ; soma o endereço base ao indice, para pegar o endereço do char
        novoTemp = generateNovoTemp()//java
        mov al, [rax] ;move o char pra al
        mov [M+novoTemp], al;move o char para o temporario
        expressão6.address = novoTemp//java
        expressão6.size = 1//java
    senão:
        expressão6.end = id.end
        expressão6.size = id.size

}


(9) {
    Expressão5.address = expressão6.address
    expressão5.size = expressão6.size
}

(10) {
    Expressão5.address = expressão.address
    expressão5.size = expressão.size
}

(11) {
    Expressão4.address = expressão5.address
    expressão4.size = expressão5.size
}


(12) {
   se expression4Type == int:
        se Expressão.type == int:
            expressão4.end = Expressão.end
            expressão4.size = Expressão.size
        senão:
            novotemp = generateNovoTemp()//java
            movss xmm0, [M+Expressão.end]
            cvtss2si rax,xmm0
            mov [M+novotemp], rax
            expressão4.end = novotemp
            expressão4.size = 4
   senão:
        se Expressão.type == int:
            novotemp = generateNovoTemp()//java
            mov eax, [M+expressão.end]
            cdqe
            cvtsi2ss xmm0,rax
            movss [M+novotemp], xmm0
            expressão4.end = novotemp
            expressão4.size = 4
        senão:
            expressão4.end = Expressão.end
            expressão4.size = Expressão.size

}

(13) {
    se shouldNegateExpression:
        novotemp = generateNovoTemp()//java
        mov eax, [M+exp4.end]
        neg eax
        add eax, 1
        mov[M+novoTemp], eax
        expressão3.end = novoTemp
        expressão3.size = expressão4.size
    senão:
        expressão3.end = expressão4.end
        expressão3.size = expressão4.size

}


(14) {
    expressão2.end = Expressão3_1.end
    expressão2.size = Expressão3_1.size
}


(15) {
    novoTemp = getNewTemp()//java
    se Expressão2.operator == *
        se Expressão2.tipo == real:
            se Expressão3_2.tipo == real:
                //mulss
                movss xmm0, [M+Expressão2.end]
                movss xmm1, [M+Expressão3_2.end]
                mulss xmm0, xmm1
                movss [M+novoTemp], xmm0
            senão:
                //converter
                mov eax, [M+Expressão3_2.end]
                cdqe
                cvtsi2ss xmm0,rax
                movss xmm1, [M+Expressão2.end]
                mulss xmm0, xmm1
                movss [M+novoTemp], xmm0
        senão:
            se Expressão3_2.tipo == real:
                mov eax, [M+Expressão2.end]
                cdqe
                cvtsi2ss xmm0,rax
                movss xmm1, [M+Expressão3_2.end]
                mulss xmm0, xmm1
                movss [M+novoTemp], xmm0
            senão:
                mov eax, [M+Expressão2.end]
                mov ebx, [M+Expressão3_2.end]
                imul ebx
                cdqe
    se Expressão2.operator == &&
        novoTemp = getNewTemporaryAdd()
        mov eax, [M+expressão2.end]
        mov ebx, [M+expressão3_2.end]
        imul ebx
        cdqe
        mov[M+novoTemp], rax
    se Expressão2.operator == /
        se Expressão2.tipo == real:
            se Expressão3_2.tipo == real:
                movss xmm0, [M+Expressão2.end]
                movss xmm1, [M+Expressão3_2.end]
                divss xmm0, xmm1
                movss [M+novoTemp], xmm0
            senão:
                mov eax, [M+Expressão3_2.end]
                cdqe
                cvtsi2ss xmm0,rax
                movss xmm1, [M+Expressão2.end]
                divss xmm1, xmm0
                movss [M+novoTemp], xmm1
        senão:
            se Expressão3_2.tipo == real:
                mov eax, [M+Expressão2.end]
                cdqe
                cvtsi2ss xmm0,rax
                movss xmm1, [M+Expressão3_2.end]
                divss xmm0, xmm1
                movss [M+novoTemp], xmm0
            senão:
                mov eax, [M+Expressão2.end]
                cdqe
                cvtsi2ss xmm0,rax
                mov eax, [M+Expressão3_2.end]
                cdqe
                cvtsi2ss xmm1,rax
                divss xmm0, xmm1
                movss [M+novoTemp], xmm0
    se Expressão2.operator == div
    se Expressão2.operator == mod


    Expressão2.end = novoTemp

}

(16) {
    se expressão1.isNegative:
        novotemp = generateNovoTemp()//java
        se Expressão2_1.tipo == real
            mov rax, -1
            cvtsi2ss xmm0, rax
            movss xmm1, [Expressão2_1.end]
            mulss xmm0, xmm1
            movss [novotemp], xmm0
            Expressão1.end = novotemp
            expressão1.size = Expressão2_1.size
        senão
            mov eax, [Expressão2_1.end]
            neg eax
            mov [novotemp], eax
            Expressão1.end = novotemp
            expressão1.size = Expressão2_1.size

    senão:
        expressão1.end = Expressão2_1.end
        expressão1.size = Expressão2_1.size
}

(17) {
    novoTemp = getNewTemp()//java
    se operador == -
        se expressão1.tipo == real:
            se Expressão2_2.tipo == real:
                movss xmm0, [M+expressão1.end]
                movss xmm1, [M+Expressão2_2.end]
                subss xmm0, xmm1
                movss [M+novotemp], xmm0
            senão:
                mov eax, [M+expressão2_2.end]
                cdqe
                cvtsi2ss xmm1,rax
                movss xmm0, [M+expressão1.end]
                subss xmm0, xmm1
                movss [M+novotemp], xmm0
        senão:
            se Expressão2_2.tipo == real:
                mov eax, [M+expressão1.end]
                cdqe
                cvtsi2ss xmm0,rax
                movss xmm1, [M+expressão2_2.end]
                subss xmm0, xmm1
                movss [M+novotemp], xmm0
            senão:
                mov eax, [M+expressão1.end]
                mov ebx, [M+expressão2_2.end]
                sub eax, ebx
                mov [M+novoTemp], eax
    se operador == +
        se expressão1.tipo == real:
            se Expressão2_2.tipo == real:
                movss xmm0, [M+expressão1.end]
                movss xmm1, [M+Expressão2_2.end]
                addss xmm0, xmm1
                movss [M+novotemp], xmm0
            senão:
                mov eax, [M+expressão2_2.end]
                cdqe
                cvtsi2ss xmm1,rax
                movss xmm0, [M+expressão1.end]
                addss xmm0, xmm1
                movss [M+novotemp], xmm0
        senão:
            se Expressão2_2.tipo == real:
                mov eax, [M+expressão1.end]
                cdqe
                cvtsi2ss xmm1,rax
                movss xmm0, [M+expressão2_2.end]
                addss xmm0, xmm1
                movss [M+novotemp], xmm0
            senão:
                mov eax, [M+expressão1.end]
                mov ebx, [M+expressão2_2.end]
                add eax, ebx
                mov [M+novoTemp], eax
    se operador ||
        mov eax, [M+expressão1.end]
        mov ebx, [M+expressão2_2.end]
        add eax, ebx
        mov ecx, 2
        idiv ecx
        add eax, edx
        mov [M+novoTemp], eax
}

(18) {
    expressão.end = Expressão1_1.end
    expressão.size = Expressão1_1.size
}


(19) {

    novoTemp = newTemporary(4)
    se Expressão.type == string:
        mov rax, M+Expressão.end
        mov rbx, M+Expressão1_2.end
        Rot1:
        mov al, [rax]
        mov bl, [rbx]
        cmp al, 0
        je Rot_Al_eh_0
        cmp bl, 0
        je Rot_Bl_eh_0
        add rax, 1
        add rbx, 1
        cmp al, bl
        je Rot1
        jmp Rot_False
        Rot_Al_eh_0:
        cmp bl, 0
        je Rot_True
        jmp Rot_False
        Rot_Bl_eh_0:
        cmp al, 0
        je Rot_True
        jmp Rot_False
        Rot_True:
        mov eax, 1
        mov [M+NovoTemp], eax
        jmp Rot_Fim
        Rot_False:
        mov eax, 0
        mov [M+NovoTemp], eax
        Rot_Fim:

    senão:
        se operador: =
            operação = je RotTrue
        se operador: !=
            operação = jne RotTrue
        se operador: <
            se Expressão.type == Real || Expressão1_2.type == Real:
                operação = jb RotTrue
            senão:
                operação = jl RotTrue
        se operador: >
            se Expressão.type == Real || Expressão1_2.type == Real:
                operação = ja RotTrue
            senão:
                operação = jg RotTrue
        se operador: <=
            se Expressão.type == Real || Expressão1_2.type == Real:
                operação = jbe RotTrue
            senão:
                operação = jle RotTrue
        se operador: >=
            se Expressão.type == Real || Expressão1_2.type == Real:
                operação = jae RotTrue
            senão:
                operação = jge RotTrue

        se Expressão.type == Real:
            se Expressão1_2 == Real:
                movss xmm0, [M+Expressão.end]
                movss xmm1, [M+Expressão1_2.end]
                comiss xmm0, xmm1
                operação
                RotFalse://gerar pelo newLabel
                mov eax, 0
                mov [M+NovoTemp], eax
                jmp RotFim
                RotTrue://gerar pelo newLabel
                mov eax, 1
                mov [M+NovoTemp], eax
                RotFim://gerar pelo newLabel
            senão:
                movss xmm0, [M+Expressão.end]
                mov eax, [M+Expressão1_2.end]
                cdqe
                cvtsi2ss xmm1, rax
                comiss xmm0, xmm1
                operação
                RotFalse://gerar pelo newLabel
                mov eax, 0
                mov [M+NovoTemp], eax
                jmp RotFim
                RotTrue://gerar pelo newLabel
                mov eax, 1
                mov [M+NovoTemp], eax
                RotFim://gerar pelo newLabel
        senão:
            se Expressão1_2 == Real:
                movss xmm0, [M+Expressão1_2.end]
                mov eax, [M+Expressão.end]
                cdqe
                cvtsi2ss xmm1, rax
                comiss xmm1, xmm0
                operação
                RotFalse://gerar pelo newLabel
                mov eax, 0
                mov [M+NovoTemp], eax
                jmp RotFim
                RotTrue://gerar pelo newLabel
                mov eax, 1
                mov [M+NovoTemp], eax
                RotFim://gerar pelo newLabel
            senão:
                mov eax, [M+Expressão.end]
                mov ebx, [M+Expressão1_2.end]
                cmp eax, ebx
                operação
                RotFalse://gerar pelo newLabel
                mov eax, 0
                mov [M+NovoTemp], eax
                jmp RotFim
                RotTrue://gerar pelo newLabel
                mov eax, 1
                mov [M+NovoTemp], eax
                RotFim://gerar pelo newLabel
}


(20) {
    se id.type == string:
        se Expressão_2.type == char:
            mov eax, [M+Expressão_1.end]
            cdqe
            mov rsi, M+id.end
            add rsi, rax
            mov bl, [M+Expressão_2.end]
            mov [rsi], bl
        senão:
            //então Expressão_2 é uma string
            mov rdi, M+id.end
            mov ebx, 0
            Rot0:
            mov al, 0
            mov [rdi], al
            add rdi, 1
            add ebx, 1
            cmp ebx, 255
            jne Rot0
            mov rdi, M+id.end
            mov rsi, M+Expressão_2.end
            Rot1:
            mov al, [rsi]
            mov [rdi], al
            add rdi, 1
            add rsi, 1
            cmp al, 0
            jne Rot1
            mov al, 0
            mov [rdi], al
            id.size = Expressão_2.size
    se id.type == float:
        se Expressão_2.type == inteiro:
            mov eax, [M+Expressão_2.end]
            cdqe
            cvtsi2ss xmm0, rax
            movss [M+id.end], xmm0
        senão:
            //então Expressão_2 é float
            movss xmm0, [M+Expressão_2.end]
            movss [M+id.end], xmm0
    se id.type == int:
        mov eax, [M+Expressão_2.end]
        mov [M+id.end], eax
    se id.type == char:
        mov al, [M+Expressão_2.end]
        mov [M+id.end], al
}

(21) {
    RotInicioWhile:
}

(22) {
    mov eax, [M+Expressão.end]
    cmp eax, 1
    jne RotFim
}

(23) {
    jmp RotInicioWhile
    RotFim:
}

(24) {
    mov eax, [M+Expressão.end]
    cmp eax, 1
    jne RotElse
}

(25) {
    jmp RotFim
    RotElse:
}

(26) {
    RotFim:
}


(27) {
    novoTemp = getNewTemp()
    se id.type == string
        mov rsi, M+novoTemp
        mov rdx, 100h ;tamanho do buffer
        mov rax, 0 ;chamada para leitura
        mov rdi, 0 ;leitura do teclado
        syscall

        mov rsi, M+novoTemp
        mov rdi, M+id.end
        mov ebx, 0
        Rot0:
        mov al, 0
        mov [rdi], al
        add rdi, 1
        add ebx, 1
        cmp ebx, 255
        jne Rot0

        mov rdi, M+id.end
        Rot1:
        mov al, [rsi]
        mov [rdi], al
        add rdi, 1
        add rsi, 1
        cmp al, 10
        jne Rot1
        sub rdi, 1
        mov al, 0
        mov [rdi], al

        id.size = Expressão_2.size
    se id.type == char
        mov rsi, M+novoTemp
        mov rdx, 100h ;tamanho do buffer
        mov rax, 0 ;chamada para leitura
        mov rdi, 0 ;leitura do teclado
        syscall
        mov rsi, M+novoTemp
        mov al, [rsi]
        mov [M+id.end], al

    se id.type == float
        mov rsi, M+novoTemp
        mov rdx, 100h ;tamanho do buffer
        mov rax, 0 ;chamada para leitura
        mov rdi, 0 ;leitura do teclado
        syscall
        mov rax, 0 ;acumul. parte int.
        subss xmm0,xmm0 ;acumul. parte frac.
        mov rbx, 0 ;caractere
        mov rcx, 10 ;base 10
        cvtsi2ss xmm3,rcx ;base 10
        movss xmm2,xmm3 ;potência de 10
        mov rdx, 1 ;sinal
        mov rsi, M+buffer.end ;end. buffer
        mov bl, [rsi] ;carrega caractere
        cmp bl, '-' ;sinal - ?
        jne Rot0 ;se dif -, salta
        mov rdx, -1 ;senão, armazena -
        add rsi, 1 ;inc. ponteiro string
        mov bl, [rsi] ;carrega caractere
        Rot0:
        push rdx ;empilha sinal
        mov rdx, 0 ;reg. multiplicação
        Rot1:
        cmp bl, 0Ah ;verifica fim string
        je Rot2 ;salta se fim string
        cmp bl, ‘.’ ;senão verifica ponto
        je Rot3 ;salta se ponto
        imul ecx ;mult. eax por 10
        sub bl, ‘0’ ;converte caractere
        add eax, ebx ;soma valor caractere
        add rsi, 1 ;incrementa base
        mov bl, [rsi] ;carrega caractere
        jmp Rot1 ;loop
        Rot3:
        ;calcula parte fracionária em xmm0
        add rsi, 1 ;inc. ponteiro string
        mov bl, [rsi] ;carrega caractere
        cmp bl, 0Ah ;*verifica fim string
        je Rot2 ;salta se fim string
        sub bl, ‘0’ ;converte caractere
        cvtsi2ss xmm1,rbx ;conv real
        divss xmm1,xmm2 ;transf. casa decimal
        addss xmm0,xmm1 ;soma acumul.
        mulss xmm2,xmm3 ;atualiza potência
        jmp Rot3 ;loop
        Rot2:
        cvtsi2ss xmm1,rax ;conv parte inteira
        addss xmm0,xmm1 ;soma parte frac.
        pop rcx ;desempilha sinal
        cvtsi2ss xmm1,rcx ;conv sinal
        mulss xmm0,xmm1 ;mult. sinal
        movss [M+id.end], xmm0
    se id.type == int
        mov rsi, M+novoTemp
        mov rdx, 100h ;tamanho do buffer
        mov rax, 0 ;chamada para leitura
        mov rdi, 0 ;leitura do teclado
        syscall
        mov eax, 0 ;acumulador
        mov ebx, 0 ;caractere
        mov ecx, 10 ;base 10
        mov dx, 1 ;sinal
        mov rsi, M+novoTemp ;end. buffer
        mov bl, [rsi] ;carrega caractere
        cmp bl, '-' ;sinal - ?
        jne Rot0 ;se dif -, salta
        mov dx, -1 ;senão, armazena -
        add rsi, 1 ;inc. ponteiro string
        mov bl, [rsi] ;carrega caractere
        Rot0:
        push dx ;empilha sinal
        mov edx, 0 ;reg. multiplicação
        Rot1:
        cmp bl, 0Ah ;verifica fim string
        je Rot2 ;salta se fim string
        imul ecx ;mult. eax por 10
        sub bl, '0' ;converte caractere
        add eax, ebx ;soma valor caractere
        add rsi, 1 ;incrementa base
        mov bl, [rsi] ;carrega caractere
        jmp Rot1 ;loop
        Rot2:
        pop cx ;desempilha sinal
        cmp cx, 0
        jg Rot3
        neg eax ;mult. sinal
        Rot3:
        mov [M+id.end], eax

}