Start -> {Declaração; | Comando} EOF
Bloco_ou_Comando -> Comando | Bloco
Bloco -> "{"{Comando}"}"
Tipo -> int (39) | float (40) | string (41) | char (42)
Declaração -> Tipo (3) Declaração_Init {, Declaração_Init} | const id = [-] const_value (1)
Declaração_Init ->  id (2) [<- [-] const_value]
Escrita -> "("Expressão {, Expressão} ")"
Comando -> id (5) ["["Expressão"]"(7)] <- Expressão (6) ; | Repetição | Teste | ; | readln"("id (5) ")" ; | (write| writeln) Escrita ;
Repetição -> while Expressão (8) Bloco_ou_Comando
Teste -> if Expressão (8) Bloco_ou_Comando [else Bloco_ou_Comando]
Operadores_Relacional -> = (11) | != (12) | < (13)| > (14) | <= (15) | >= (16)

Expressão -> Expressão1_1 (9) [Operadores_Relacional Expressão1_2 (10)]
Expressão1 -> [- (21)] Expressão2_1 (22) {(- (18) | + (19) | || (20) )  Expressão2_2 (17)}
Expressão2 -> Expressão3_1(31) {(*(24) | &&(25) | /(26) | div (27)| mod(28)) Expressão3_2 (23)}
Expressão3 -> {!(29)} Expressão4 (30)
Expressão4 -> ( (int | float) "("Expressão (32)")"  | Expressão5 (33))
Expressão5 -> "(" Expressão (34) ")" | Expressão6 (35)
Expressão6 -> const_value (36) | id (4) ["[" Expressão (37) "]"] (38)


Esquema de Tradução:
Done
1 {
    se id.class == null:
        id.class = CONST, id.type = const_value.type
    senão:
        error
}
Done
2 {
    se id.class == null:
        id.class = VAR, id.type = Declaração_Init.type
    senão:
        error
}
Done
3 {
    Declaração_Init.type = Tipo.type
}
4 {
    se id.class == null então:
        error
 }
Done
5 {
      se id.class == null ou id.class == constante então:
          error
}

6 {
    se comando.hasStringAccess && Expressão.type != char então:
        error
    senão se id.type == float && (expressão.type != inteiro && expressão.type != float) :
        error
    senão se id.type != Expressão.type então:
        error
}

7 {
    se id.type != String então:
        error
    senão se expressão.type != inteiro então:
        error
    senão:
        comando.hasStringAccess = true
}

8 {
    se expressão.type != booleano então:
        error
}

9 {
    expressão.type = expressão1_1.type
}

10 {
    expressão.type = boolean
    se (expressão1_1.type == inteiro || expressão1_1.type == float) && expressão1_2.type == char:
            error
    senão se (expressão1_2.type == inteiro == expressão1_2.type == float) && expressão1_1.type == char:
        error
    senão expressão1_1.type == string && expressão1_2.type == string:
        se operadores_relacional.operator != '=':
            error
    senão expressão1_1.type == string || expressão1_2.type == string:
        error
    senão se expressão1_1.type == boolean || expressão1_2.type == boolean:
        error
}

11 {
    Operadores_Relacional.operator = '='
}

12 {
    Operadores_Relacional.operator = '!='
}

13 {
    Operadores_Relacional.operator = '<'
}

14 {
    Operadores_Relacional.operator = '>'
}

15 {
    Operadores_Relacional.operator = '<='
}

16 {
    Operadores_Relacional.operator = '>='
}
17 {
    se Expressão2_1.type == string || Expressão2_1.type == char || Expressão2_2.type == string || Expressão2_2.type == char:
        error
    se Expressão2_1.type == boolean && Expressão2_2.type == boolean:
        Expressão1.type = boolean
        se Expressão1.operadorAtual != '||':
            error
    senão Expressão2_1.type == boolean || Expressão2_2.type == boolean:
        error
    senão Expressão2_1.type == float || Expressão2_2.type == float:
        expressão1.type = float
    senão:
        expressão1.type = int
    se Expressão2.operadorAtual == '||':
        error
}

18 {
    Expressão1.operadorAtual = '-'
}
19 {
    Expressão1.operadorAtual = '+'
}
20 {
    Expressão1.operadorAtual = '||'
}

21 {
    Expressão1.isNegative = true
}

22 {
    se Expressão2_1.type == boolean && Expressão1.isNegative:
        error
    Expressão1.type = Expressão2_1.type
}

Expressão2 -> Expressão3_1 {(*(24) | &&(25) | /(26) | div (27)| mod(28)) Expressão3_2 (23)}
23 {
      se Expressão3_1.type == string || Expressão3_1.type == char || Expressão3_2.type == string || Expressão3_2.type == char:
             error
      se Expressão3_1.type == boolean && Expressão3_2.type == boolean:
          Expressão2.type = boolean
          se Expressão2.operadorAtual != '&&':
              error
      senão Expressão3_1.type == boolean || Expressão3_2.type == boolean:
          error
      senão Expressão3_1.type == float || Expressão3_2.type == float:
          expressão2.type = float
          se Expressão2.operadorAtual == 'div' || Expressão2.operadorAtual == 'mod':
            error
      senão:
          expressão2.type = int
      se Expressão2.operadorAtual == '&&':
        error
}

24 {
    Expressão2.operadorAtual = '*'
}
25 {
    Expressão2.operadorAtual = '&&'
}
26 {
    Expressão2.operadorAtual = '/'
}

27 {
    Expressão2.operadorAtual = 'div'
}

28 {
    Expressão2.operadorAtual = 'mod'
}

29 {
   Expressão3.hasExclamationOperator = true
}

30 {
    se Expressão3.hasExclamationOperator && Expressão4.type != boolean:
        error
    Expressão3.type = Expressão4.type
}

31 {
    Expressão2.type = Expressão3_1.type
}

32 {
    se Expressão.type != int || Expressão.type != float:
        error
    Expresão4.type = Expressão.type
}

33 {
    Expresão4.type = Expressão5.type
}


34 {
    Expressão5.type = Expressão.type
}

35 {
    Expressão5.type = Expressão6.type
}


36 {
    Expressão6.type = const_value.type
}


37 {
    se expressão.type != inteiro então:
          error
}

38 {
    Expressão6.type = id.type
}
Done
39 {
    Tipo.type = int
}
Done
40 {
    Tipo.type = float
}
Done
41 {
    Tipo.type = string
}
Done
42 {
    Tipo.type = char
}