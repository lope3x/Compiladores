Start -> {Declaração; | Comando} EOF
Bloco_ou_Comando -> Comando | Bloco
Bloco -> "{"{Comando}"}"
Tipo -> int  | float | string | char
Declaração -> Tipo (3) Declaração_Init {, (7) Declaração_Init} | const id = [-] const_value (1)
Declaração_Init ->  id (2) [<- [-] const_value]
Escrita -> "("Expressão {, Expressão} ")"
Comando -> id (4) ["["Expressão"]"] <- Expressão ; | Repetição | Teste | ; | readln"("id (5) ")" ; | (write| writeln) Escrita ;
Repetição -> while Expressão Bloco_ou_Comando
Teste -> if Expressão Bloco_ou_Comando [else Bloco_ou_Comando]
Operadores_Relacional -> = | != | < | > | <= | >=
Expressão -> Expressão1 { Operadores_Relacional Expressão1}
Expressão1 -> [-] Expressão2 {(- | + | || )  Expressão2}
Expressão2 -> Expressão3 {(* | && | / | div | mod) Expressão3}
Expressão3 -> {!} Expressão4
Expressão4 -> ( (int | float) "("Expressão")"  | Expressão5)
Expressão5 -> "(" Expressão ")" | Expressão6
Expressão6 -> const_value | id (4) ["[" Expressão "]"]


Esquema de Tradução:
1 { id.class = CONST, id.type = const_value.type }  // Validar se não foi setado o type previamente
2 { id.class = VAR, id.type = Declaração_Init.type } // Validar se não foi setado o type previamente
3 { Declaração_Init.type = Tipo.type }
4 {
    se id.class == null então:
        error
 }

//Perguntar pro prof
5 {
      se id.class == null ou id.class == constante então:
          error
}

